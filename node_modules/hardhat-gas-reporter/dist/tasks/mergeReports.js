"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.taskMergeImplementation = exports.subtaskMergeReportsImplementation = exports.mergeReports = void 0;
const plugins_1 = require("hardhat/plugins");
const task_names_1 = require("../task-names");
/**
 * Tries to merge several gas reporter output objects into one.
 */
async function mergeReports(reports, inputFiles) {
    const result = {
        namespace: null,
        toolchain: null,
        options: null,
        data: {
            methods: {},
            deployments: [],
            blockLimit: null,
        },
    };
    const { HardhatGasReporterOutputValidator } = await Promise.resolve().then(() => __importStar(require("../lib/validators/hardhat")));
    for (const [index, report] of reports.entries()) {
        const Validator = new HardhatGasReporterOutputValidator();
        Validator.validateOutputObject(report, inputFiles[index]);
        if (result.options === null)
            result.options = report.options;
        if (result.namespace === null)
            result.namespace = report.namespace;
        if (result.toolchain === null)
            result.toolchain = report.toolchain;
        // Merge data.methods objects
        Object.entries(report.data.methods).forEach(([key, value]) => {
            Validator.validateMethodDataItem(value, inputFiles[index]);
            if (result.data.methods[key] === undefined) {
                result.data.methods[key] = value;
                return;
            }
            result.data.methods[key].gasData = [
                ...result.data.methods[key].gasData,
                ...report.data.methods[key].gasData,
            ].sort((a, b) => a - b);
            result.data.methods[key].callData = [
                ...result.data.methods[key].callData,
                ...report.data.methods[key].callData,
            ].sort((a, b) => a - b);
            result.data.methods[key].numberOfCalls +=
                report.data.methods[key].numberOfCalls;
        });
        // Merge data.deployments objects
        report.data.deployments.forEach((deployment) => {
            const current = result.data.deployments.find((d) => d.name === deployment.name);
            if (current !== undefined) {
                current.gasData = [...current.gasData, ...deployment.gasData].sort((a, b) => a - b);
                current.callData = [...current.callData, ...deployment.callData].sort((a, b) => a - b);
            }
            else {
                result.data.deployments.push(deployment);
            }
        });
    }
    return result;
}
exports.mergeReports = mergeReports;
/**
 * Task for merging multiple gasReporterOutput.json files generated by the plugin
 * This task is necessary when we want to generate different parts of the reports
 * parallelized on different jobs.
 */
async function subtaskMergeReportsImplementation({ inputFiles }) {
    const fs = await Promise.resolve().then(() => __importStar(require("fs")));
    const reports = inputFiles.map((input) => JSON.parse(fs.readFileSync(input, "utf-8")));
    return mergeReports(reports, inputFiles);
}
exports.subtaskMergeReportsImplementation = subtaskMergeReportsImplementation;
;
async function taskMergeImplementation(taskArguments, hre) {
    const path = await Promise.resolve().then(() => __importStar(require("path")));
    const { globSync } = await Promise.resolve().then(() => __importStar(require("glob")));
    const { uniq } = await Promise.resolve().then(() => __importStar(require("lodash")));
    const { reportMerge } = await Promise.resolve().then(() => __importStar(require("../utils/ui")));
    const { GasData } = await Promise.resolve().then(() => __importStar(require("../lib/gasData")));
    const { setGasAndPriceRates } = await Promise.resolve().then(() => __importStar(require("../utils/prices")));
    const { generateJSONData } = await Promise.resolve().then(() => __importStar(require("../lib/render/json")));
    const output = path.resolve(process.cwd(), taskArguments.output);
    // Parse input files and calculate glob patterns
    const taskArgs = uniq(taskArguments.input.map((input) => globSync(input)).flat());
    const files = taskArgs.map((file) => path.resolve(file));
    if (files.length === 0) {
        throw new plugins_1.HardhatPluginError(`hardhat-gas-reporter`, `No files found for the given input: ${taskArguments.input.join(" ")}`);
    }
    reportMerge(files, output);
    const result = await hre.run(task_names_1.TASK_GAS_REPORTER_MERGE_REPORTS, { inputFiles: files });
    const warnings = await setGasAndPriceRates(result.options);
    const data = new GasData(result.data.methods, result.data.deployments);
    await data.runAnalysis(hre, result.options);
    // Write warnings
    for (const warning of warnings)
        console.log(warning);
    // Write json
    result.options.outputJSONFile = output;
    generateJSONData(data, result.options);
}
exports.taskMergeImplementation = taskMergeImplementation;
;
//# sourceMappingURL=mergeReports.js.map