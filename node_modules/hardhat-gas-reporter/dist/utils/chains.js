"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L2 = exports.L1 = exports.getBaseFeePerByteUrlForChain = exports.getBlobBaseFeeUrlForChain = exports.getBlockUrlForChain = exports.getGasPriceUrlForChain = exports.getTokenForChain = void 0;
const constants_1 = require("../constants");
/**
 * Returns the CMC token symbol for a chain's native token. Uses chain configs below
 * and defers to user overrides
 * @param {GasReporterOptions} options
 * @returns
 */
function getTokenForChain(options) {
    if (options.token)
        return options.token;
    // Gets caught and translated to warning
    if (!exports.L1[options.L1])
        throw new Error();
    return exports.L1[options.L1].token;
}
exports.getTokenForChain = getTokenForChain;
/**
 * Gets Etherscan gasPrice api call url for chain. Attaches L1 or L2 apikey if configured
 * @param {GasReporterOptions} options
 * @returns
 */
function getGasPriceUrlForChain(options) {
    let apiKey = "";
    if (options.gasPriceApi)
        return options.gasPriceApi;
    if (options.L2) {
        if (!exports.L2[options.L2])
            throw new Error;
        apiKey = (options.L2Etherscan)
            ? `${constants_1.DEFAULT_API_KEY_ARGS}${options.L2Etherscan}`
            : "";
        return `${exports.L2[options.L2].baseUrl}${constants_1.DEFAULT_GAS_PRICE_API_ARGS}${apiKey}`;
    }
    if (!exports.L1[options.L1])
        throw new Error();
    return `${exports.L1[options.L1].baseUrl}${constants_1.DEFAULT_GAS_PRICE_API_ARGS}${apiKey}`;
}
exports.getGasPriceUrlForChain = getGasPriceUrlForChain;
/**
 * Gets Etherscan getBlock api call url for chain. Attaches L1 apikey if configured
 * (THIS IS ALWAYS for L1 data-related fees in the context of L2 execution)
 * @param {GasReporterOptions} options
 * @returns
 */
function getBlockUrlForChain(options) {
    if (!options.L2)
        return "";
    if (options.getBlockApi)
        return options.getBlockApi;
    const apiKey = (options.L1Etherscan)
        ? `${constants_1.DEFAULT_API_KEY_ARGS}${options.L1Etherscan}`
        : "";
    if (!exports.L1[options.L1])
        throw new Error();
    return `${exports.L1[options.L1].baseUrl}${constants_1.DEFAULT_GET_BLOCK_API_ARGS}${apiKey}`;
}
exports.getBlockUrlForChain = getBlockUrlForChain;
/**
 * Gets Etherscan eth_call api url to read OP Stack GasPriceOracle for blobBaseFee.
 * Attaches L2 apikey if configured. (This fee fetched from L2 contract b/c its the only available place at
 * time of PR - eth_blobBaseFee hasn't been implemented in geth yet)
 * @param {GasReporterOptions} options
 * @returns
 */
function getBlobBaseFeeUrlForChain(options) {
    if (!options.L2)
        return "";
    if (options.blobBaseFeeApi)
        return options.blobBaseFeeApi;
    const apiKey = (options.L2Etherscan)
        ? `${constants_1.DEFAULT_API_KEY_ARGS}${options.L2Etherscan}`
        : "";
    return `${exports.L2[options.L2].baseUrl}${constants_1.DEFAULT_BLOB_BASE_FEE_API_ARGS}${exports.L2[options.L2].gasPriceOracle}${apiKey}`;
}
exports.getBlobBaseFeeUrlForChain = getBlobBaseFeeUrlForChain;
/**
 * Gets Etherscan eth_call api url to read OP Stack GasPriceOracle for blobBaseFee.
 * Attaches L2 apikey if configured. (This fee fetched from L2 contract b/c its the only available place at
 * time of PR - eth_blobBaseFee hasn't been implemented in geth yet)
 * @param {GasReporterOptions} options
 * @returns
 */
function getBaseFeePerByteUrlForChain(options) {
    if (options.L2 !== "arbitrum")
        return "";
    const apiKey = (options.L2Etherscan)
        ? `${constants_1.DEFAULT_API_KEY_ARGS}${options.L2Etherscan}`
        : "";
    return `${exports.L2[options.L2].baseUrl}${constants_1.DEFAULT_BASE_FEE_PER_BYTE_API_ARGS}${apiKey}`;
}
exports.getBaseFeePerByteUrlForChain = getBaseFeePerByteUrlForChain;
/**
 * L1 & L2 chain configurations for fetching gas price and block fee data from Etherscan as well
 * as currency prices from Coinmarketcap
 */
exports.L1 = {
    ethereum: {
        baseUrl: "https://api.etherscan.io/api?module=proxy&",
        token: "ETH"
    },
    polygon: {
        baseUrl: "https://api.polygonscan.com/api?module=proxy&",
        token: "POL"
    },
    binance: {
        baseUrl: "https://api.bscscan.com/api?module=proxy&",
        token: "BNB"
    },
    fantom: {
        baseUrl: "https://api.ftmscan.com/api?module=proxy&",
        token: "FTM"
    },
    moonbeam: {
        baseUrl: "https://api-moonbeam.moonscan.io/api?module=proxy&",
        token: "GLMR"
    },
    moonriver: {
        baseUrl: "https://api-moonriver.moonscan.io//api?module=proxy&",
        token: "MOVR"
    },
    gnosis: {
        baseUrl: "https://api.gnosisscan.io/api?module=proxy&",
        token: "XDAI"
    },
    avalanche: {
        baseUrl: "https://api.snowtrace.io/api?module=proxy&",
        token: "AVAX"
    }
};
exports.L2 = {
    optimism: {
        baseUrl: "https://api-optimistic.etherscan.io/api?module=proxy&",
        gasPriceOracle: "0x420000000000000000000000000000000000000F",
        token: "ETH"
    },
    base: {
        baseUrl: "https://api.basescan.org/api?module=proxy&",
        gasPriceOracle: "0x420000000000000000000000000000000000000F",
        token: "ETH"
    },
    arbitrum: {
        baseUrl: "https://api.arbiscan.io/api?module=proxy&",
        gasPriceOracle: "",
        token: "ETH"
    }
};
//# sourceMappingURL=chains.js.map